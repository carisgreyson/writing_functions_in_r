---
output: rmarkdown::github_document
---

## "Real-world" example functions.

This section builds on material covered in the [Intro R Training](https://github.com/moj-analytical-services/IntroRTraining) course. The `dplyr` package is a commonly used R package for data manipulation, such as creating summary tables.

First of all we need to load a few packages. `s3tools` is an MoJ package designed to interact with Amazon s3 - we will need this to help read in some data from an s3 bucket. `dplyr` is the package we'll use to create summary tables from the data. `janitor` is another useful package that can be used to help clean data.

```{r message=F, warning=F}
# Load packages
library(s3tools)
library(dplyr)
library(janitor)
```

Here we are reading in the `Prosecutions and Convictions` dataset from s3 and storing the dataframe as a variable called `cases`.

```{r message=F, warning=F}
cases <- s3tools::s3_path_to_full_df("alpha-everyone/r_functions_training/prosecutions-and-convictions-2018.csv")

# Filter for Magistrates Court to extract the prosecutions
cases <- cases %>%
  filter(`Court.Type` == "Magistrates Court")
```

Here's a preview of the data stored in `cases`:

```{r}
head(cases)
```

Let's say we wanted to create a summary table showing the number of people prosecuted in different age bands. We could do:

```{r}
cases_grouped <- cases %>%
  group_by(Age.Range) %>%
  summarise(counts = sum(Count)) %>% 
  adorn_totals("row")
```

In the above code we are grouping the `cases` dataframe by the categories in the `Age.Range` column, then summarising the number of prosecutions in each of those categories by summing the `Count` column. The bottom line uses a function from the `janitor` package to add a row containing the total number of prosecutions in all categories. The resulting dataframe is saved as a variable called `cases_grouped`. Notice how the `dplyr` functions `group_by()` and `summarise()` require that the column names are not enclosed in quotation marks: this behaviour is known as non-standard evalution, and will be important later.

```{r}
cases_grouped
```

What if we wanted to create several different summary tables? We could write a function to avoid writing this out each time. Following the previous examples in this course, you might expect this function to work:

```{r error = TRUE}
sum_group <- function(df, group_cols, sum_col) {
  
  summary <- df %>%
    group_by(group_cols) %>%
    summarise(counts = sum(sum_col)) %>% 
    adorn_totals("row")
  
  return(summary)
  
}
```

However trying to use this function results in an error.

```{r error = TRUE}
cases_grouped <- sum_group(df = cases, group_cols = "Age.Range", sum_col = "Count")
```

This is because of the non-standard evalutation (NSE) mentioned above. The `dplyr` functions don't recognise `group_cols` and `sum_col` as column names, because they can't see that these are variables containing the actual column names. While the NSE usually makes the `dplyr` functions more convenient to use, it makes them slightly trickier to use in user-defined functions. 

Fortunately to get around the NSE problem, functions have been added to the `dplyr` package that accept variables instead of straight column names. The function below shows an example of how the functions `group_by_at` and `summarise_at` can replace `group_by` and `summarise`.

```{r}

sum_group <- function(df, group_cols, sum_col) {
  
  summary <- df %>%
    group_by_at(group_cols) %>%
    summarise_at(sum_col, sum) %>% 
    adorn_totals("row")
  
  return(summary)
  
}

cases_grouped <- sum_group(df = cases, group_cols = "Age.Range", sum_col = "Count")

cases_grouped

```

If you still wanted to use the `group_by` and `summarise` functions in a user-defined function, then variables containing the column names can be enclosed by `!!as.name()` to convert them into straight column names, like so:

```{r}

sum_group <- function(df, group_cols, sum_col) {
  
  summary <- df %>%
    group_by(!!as.name(group_cols)) %>%
    summarise(counts = sum(!!as.name(sum_col))) %>% 
    adorn_totals("row")
  
  return(summary)
  
}

cases_grouped <- sum_group(df = cases, group_cols = "Age.Range", sum_col = "Count")

cases_grouped

```

We can make this function more general by making the total row optional:

```{r}

sum_group <- function(df, group_cols, sum_col, add_total=F) {
  
  summary <- df %>%
    group_by_at(group_cols) %>%
    summarise(counts = sum(!!as.name(sum_col)))
  
  if (add_total == T) {
    summary <- summary %>% adorn_totals("row")
  }
  
  return(summary)
  
}

cases_grouped <- sum_group(df = cases, group_cols = "Age.Range", sum_col = "Count", add_total=F)

cases_grouped

```

The `sum_group()` function also allows us to add any number of grouping columns:

```{r}

cases_grouped <- sum_group(df = cases, 
                           group_cols = c("Age.Range", "Offence.Group"), 
                           sum_col = "Count",
                           add_total=T)

head(cases_grouped)

```

Here's another example: say we want to produce some plots, and want them all to have the same style. We can define the style of the plot in a function, then we only have to change the styling in one place if it needs changing. Here we've gone for a line chart with a red line.

```{r}
make_line_chart <- function(df, x_col, y_col){
  
  x <- df %>% pull(x_col)
  y <- df %>% pull(y_col)
  
  plot(x, y, col='red', type='l', xlab=x_col, ylab=y_col)
  
}
```

Let's use the `sum_group()` and `make_line_chart()` functions to produce a plot of the number of prosecutions in each year.

```{r}

time_series <- sum_group(df = cases, 
                         group_cols = c("Year"), 
                         sum_col = "Count")

make_line_chart(time_series, x="Year", y="counts")

```


More ideas -

- A graph where you can vary which offence is plotted and/or whether it plots “Offence Type” or “Offence Group” (though this probably would have to use NSE)
- Data cleaning stuff, e.g. removing the “01: ” etc from the start of the categories (you could then reuse the function on each of the columns)
- Your `generalised_names()` function would work well for cleaning the column names of the CSV
- As an example of calling functions within functions is we could have a `clean_prosecutions_and_convictions()` function which uses some of the above
- Function which pulls out the most recent year and quarter in the data?
- A function which makes a table broken down by different variables. E.g. # defendants prosecuted by ethnicity & year; offence & year etc
- Custom function which replaces not known values with NA or some other consistent value? E.g. ’04: Not known’, ’05: Not known’, ’12: Not known (Juvenile)’ etc



